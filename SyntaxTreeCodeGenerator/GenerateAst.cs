using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace SyntaxTreeCodeGenerator
{
    class GenerateAst
    {
        static string NL = Environment.NewLine;

        static void Main(string[] args)
        {
            string outputDir = args.Length != 1 ? @"C:\drojf\large_projects\craftinginterpreters\craftinginterpreters2" : args[0];
            if (args.Length != 1)
            {
                //Console.Error.WriteLine("Usage: generate_ast <output directory>");
                //Environment.Exit(1);
            }

            defineAst(outputDir, "Expr", new List<string>()
            {
                "Assign     : Token name, Expr value",
                "Binary     : Expr left, Token op, Expr right",
                "Call       : Expr callee, Token paren, List<Expr> arguments",
                "Grouping   : Expr expression",
                "Literal    : Object value",
                "Logical    : Expr left, Token op, Expr right",
                "Unary      : Token op, Expr right",
                "Variable   : Token name",
            });

            defineAst(outputDir, "Stmt", new List<string>()
            {
                "Block      : List<Stmt> statements",
                "Expression : Expr expression",
                "Function   : Token name, List<Token> parameters, List<Stmt> body",
                "If         : Expr condition, Stmt thenBranch, Stmt elseBranch",
                "Print      : Expr expression",
                "Return     : Token keyword, Expr value",
                "Var        : Token name, Expr initializer",
                "While      : Expr condition, Stmt body",
            });
        }

        private static void defineAst(string outputDir, string baseName, List<string> types)
        {
            string path = Path.Combine(outputDir, baseName) + ".cs";
            using(FileStream fs = new FileStream(path, FileMode.Create))
            using(StreamWriter writer = new StreamWriter(fs, System.Text.Encoding.UTF8))
            {
                writer.WriteLine($"//THIS FILE IS AUTOMATICALLY GENERATED - do not edit manually");

                writer.WriteLine($"using System;" + NL);
                writer.WriteLine($"using System.Collections.Generic;" + NL);
                writer.WriteLine();
                writer.WriteLine("namespace craftinginterpreters2");
                writer.WriteLine("{");

                writer.WriteLine($"public abstract class {baseName} {{" + NL);

                defineVisitor(writer, baseName, types);

                writer.WriteLine("    public abstract R Accept<R>(Visitor<R> visitor);" + NL);

                foreach (string type in types)
                {
                    Console.WriteLine($"Generating {type}...");
                    List<string> splitType = type.Split(":").Select(x => x.Trim()).ToList();
                    string className = splitType[0];
                    string fields = splitType[1];
                    defineType(writer, baseName, className, fields);
                }

                writer.WriteLine("}"); //end abstract class
                writer.WriteLine("}"); //end namespace
            }
        }

        private static void defineVisitor(StreamWriter writer, string baseName, List<string> types)
        {
            writer.WriteLine("   public interface Visitor<R> {");

            foreach(string type in types)
            {
                String typeName = type.Split(":")[0].Trim();
                writer.WriteLine($"    R Visit{typeName}{baseName} ({typeName} {baseName.ToLower()});");
            }

            writer.WriteLine("    }" + NL);
        }

        private static void defineType(StreamWriter writer, string baseName, string className, string fieldList)
        {
            string[] fields = fieldList.Split(", ");

            writer.WriteLine($"    public class {className} : {baseName} {{");

            //Fields
            foreach (string field in fields)
            {
                writer.WriteLine($"        public readonly {field};");
            }
            writer.WriteLine();

            //Constructor
            {
                writer.WriteLine($"        public {className} ({fieldList}) {{");

                // Store parameters in fields.
                foreach (string field in fields)
                {
                    string name = field.Split(" ")[1];
                    writer.WriteLine($"            this.{name} = {name};");
                }

                writer.WriteLine("        }");
            }

            // Visitor pattern.
            writer.WriteLine();
            writer.WriteLine($"        public override R Accept<R>(Visitor<R> visitor) {{");
            writer.WriteLine($"            return visitor.Visit{className}{baseName}(this);");
            writer.WriteLine("        }");

            writer.WriteLine("    }" + NL);
        }
    }
}
